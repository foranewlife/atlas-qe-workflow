"""
EOS Post-Processing: parse energies/volumes per curve, fit EOS, and plot.

Inputs:
- eos.json (generated by aqflow eos), which contains tasks, structures_info, combinations_info, curves_index

Outputs (under aqflow_data/ by default):
- eos_post.json: multi-curve structured data (per-curve points + fits)
- eos_points.tsv: tabular data with columns: volume_scale, volume_A3_per_atom, energy_eV_per_atom, status, structure, combination, workdir
- Per-structure plots: eos_curve_<structure>.png and eos_curve_relative_<structure>.png
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import json
import time
import logging

from .models import EosModel
from aqflow.software.parsers import parse_volume as sw_parse_volume
import numpy as np
import matplotlib
# Force non-interactive backend to avoid any GUI/blocking behavior
matplotlib.use("Agg", force=True)
import matplotlib.pyplot as plt

logger = logging.getLogger(__name__)
from pymatgen.analysis.eos import EOS

# Assume dependencies exist per project convention; no auto-install here.


def _detect_software_from_combo(combination: str) -> Optional[str]:
    c = (combination or "").lower()
    if "qe" in c:
        return "qe"
    if "atlas" in c:
        return "atlas"
    return None


# Energy parsing has been moved upstream (EOS writes energies to eos.json)


def _parse_volume_any(software: str, workdir: Path) -> Optional[float]:
    return sw_parse_volume(software, workdir)


def _polyfit_quadratic(xs: List[float], ys: List[float]) -> Optional[Tuple[float, float, float]]:
    """Fit y = a x^2 + b x + c via least squares (stable for small N)."""
    if len(xs) < 3:
        return None
    X = np.vstack([np.array(xs) ** 2, np.array(xs), np.ones(len(xs))]).T
    try:
        a, b, c = np.linalg.lstsq(X, np.array(ys), rcond=None)[0]
        return float(a), float(b), float(c)
    except Exception:
        return None


def _fit_pymatgen(vols: List[float], ys: List[float], model: str) -> Tuple[Optional[Dict], Optional[object]]:
    if len(vols) >= 3 and len(vols) == len(ys):
        try:
            eos = EOS(eos_name=model)
            fit = eos.fit(vols, ys)
            return (
                {
                    "e0": float(fit.e0),
                    "v0": float(fit.v0),
                    "b0_GPa": float(fit.b0_GPa),
                    "b1": float(fit.b1),
                    "n_points": len(vols),
                },
                fit,
            )
        except Exception as ex:
            return ({"error": f"pymatgen fit failed: {ex}"}, None)
    return (None, None)


def _base_dir_from_model(model: EosModel, eos_json_path: Path) -> Path:
    try:
        return Path(model.meta.config_path).parent
    except Exception:
        return eos_json_path.parent


def _combination_software(model: EosModel, combo_name: str) -> Optional[str]:
    info = (model.combinations_info or {}).get(combo_name) if hasattr(model, "combinations_info") else None
    if info and isinstance(info, dict):
        sw = info.get("software")
        if isinstance(sw, str) and sw:
            return sw
    return _detect_software_from_combo(combo_name)


    # removed: no special per-atom handling; energy parsing unified via software parsers


@dataclass
class EosPostProcessor:
    eos_json: Path = Path.cwd() / "aqflow_data" / "eos.json"
    out_json: Path = Path.cwd() / "aqflow_data" / "eos_post.json"
    out_tsv: Path = Path.cwd() / "aqflow_data" / "eos_points.tsv"
    fit: str = "quad"  # "none" | "quad"
    eos_model_name: str = "birch_murnaghan"  # pymatgen EOS model name
    make_plots: bool = True
    abs_png: Path = Path.cwd() / "aqflow_data" / "eos_curve.png"
    rel_png: Path = Path.cwd() / "aqflow_data" / "eos_curve_relative.png"

    def run(self) -> Dict:
        raw = json.loads(Path(self.eos_json).read_text())
        model = EosModel.model_validate(raw)

        # Accumulate all points (flat) and group into curves by (structure|combination)
        all_points: List[Dict] = []
        curves: Dict[str, Dict] = {}
        # Resolve relative paths against config directory
        try:
            base_dir = Path(model.meta.config_path).parent
        except Exception:
            base_dir = Path(self.eos_json).parent
        for t in model.tasks:
            # Only consider succeeded tasks; ignore failed/timeout by design
            if (t.status or "").lower() != "succeeded":
                continue
            # Resolve workdir
            workdir_path = Path(t.workdir)
            if not workdir_path.is_absolute():
                workdir_path = base_dir / workdir_path
            # Determine software for volume parsing; energy comes from eos.json
            software = _combination_software(model, t.combination) or "qe"
            e = t.energy
            # Determine volume via software parser
            vol = _parse_volume_any(software, workdir_path)
            # Persist volume back to model so eos.json contains volume info
            try:
                t.volume = vol  # type: ignore[attr-defined]
            except Exception:
                pass

            point = {
                "structure": t.structure,
                "combination": t.combination,
                "volume_scale": t.volume_scale,
                "energy_eV": e,
                "status": t.status,
                "workdir": t.workdir,
                "volume_A3": vol,
            }
            all_points.append(point)
            logger.info(
                f"Parsed task {workdir_path}: energy={e}, volume={vol}, status={t.status}"
            )

            # Group key: one curve per (structure, combination)
            key = f"{t.structure}|{t.combination}"
            cur = curves.setdefault(key, {
                "key": key,
                "structure": t.structure,
                "combination": t.combination,
                "software": software,
                "points": [],
            })
            cur["points"].append(point)
            

        # Per-curve fits
        curves_out: List[Dict] = []
        for key, cur in curves.items():
            # Only successful points were added above; still ensure energy exists
            pts_ok = [p for p in cur["points"] if p["energy_eV"] is not None]
            xs: List[float] = [float(p["volume_scale"]) for p in pts_ok]
            ys: List[float] = [float(p["energy_eV"]) for p in pts_ok]
            vols: List[float] = [float(p["volume_A3"]) for p in pts_ok if p["volume_A3"] is not None]
            # Skip this curve if there are <= 3 successful points
            if len(xs) <= 3:
                logger.warning(f"Skipping curve {key}: only {len(xs)} successful points (<= 3)")
                continue
            fit_result: Dict[str, Optional[float] | str | int] = {"method": self.fit}
            if self.fit == "quad" and len(xs) >= 3:
                sol = _polyfit_quadratic(xs, ys)
                if sol:
                    a, b, c = sol
                    vmin = None
                    emin = None
                    if abs(a) > 1e-12:
                        vmin = -b / (2 * a)
                        emin = a * vmin * vmin + b * vmin + c
                    fit_result.update(
                        {
                            "a": a,
                            "b": b,
                            "c": c,
                            "vmin": vmin,
                            "emin": emin,
                            "n_points": len(xs),
                        }
                    )

            # pymatgen EOS fit per-curve
            pmg_fit, eos_fit_obj = _fit_pymatgen(vols, ys, self.eos_model_name)

            curves_out.append(
                {
                    "key": key,
                    "structure": cur["structure"],
                    "combination": cur["combination"],
                    "software": cur["software"],
                    "points": cur["points"],
                    "fit": fit_result,
                    "pmg_fit": pmg_fit,
                    "_eos_fit_obj": eos_fit_obj,  # internal use for plotting; popped later
                }
            )

        out_obj: Dict = {
            "meta": {
                "created_at": time.time(),
                "source": str(self.eos_json),
                "fit": self.fit,
                "pymatgen_eos": self.eos_model_name,
            },
            # flat points retained for quick grep; multi-curve lives in curves
            "points": all_points,
            "curves": [],  # will fill without private keys
        }

        # Plotting: one figure per structure (absolute and relative)
        if self.make_plots and curves_out:
            # Group curves by structure
            by_struct: Dict[str, List[Dict]] = {}
            for cur in curves_out:
                by_struct.setdefault(cur["structure"], []).append(cur)

            abs_map: Dict[str, str] = {}
            rel_map: Dict[str, str] = {}
            abs_html_map: Dict[str, str] = {}
            rel_html_map: Dict[str, str] = {}

            for struct, scurves in by_struct.items():
                fig_abs, ax_abs = plt.subplots(figsize=(9, 6))
                fig_rel, ax_rel = plt.subplots(figsize=(9, 6))

                # Prepare Plotly figures (interactive)
                try:
                    import plotly.graph_objects as go  # noqa: WPS433 (runtime import)
                    from plotly.io import write_html  # noqa: WPS433
                    use_plotly = True
                except Exception:
                    use_plotly = False
                if use_plotly:
                    fig_abs_pl = go.Figure()
                    fig_rel_pl = go.Figure()

                # Colors per structure's curves
                n = max(1, len(scurves))
                cmap = plt.cm.get_cmap("tab10", min(10, n)) if n <= 10 else plt.cm.get_cmap("tab20", min(20, n))

                for idx, cur in enumerate(scurves):
                    color = cmap(idx % cmap.N)
                    vols = np.array([p["volume_A3"] for p in cur["points"] if p["energy_eV"] is not None and p["volume_A3"] is not None], dtype=float)
                    ens = np.array([p["energy_eV"] for p in cur["points"] if p["energy_eV"] is not None and p["volume_A3"] is not None], dtype=float)
                    if len(vols) == 0:
                        continue
                    order = np.argsort(vols)
                    v = vols[order]
                    e = ens[order]

                    # Legend: combination [B0=.. GPa]
                    pmg = cur.get("pmg_fit") or {}
                    if isinstance(pmg, dict) and pmg.get("b0_GPa") is not None and not pmg.get("error"):
                        label = f"{cur['combination']} | B0={pmg['b0_GPa']:.2f} GPa"
                    else:
                        label = f"{cur['combination']}"
                    ax_abs.scatter(v, e, color=color, s=45, alpha=0.8, zorder=3, label=label)
                    if use_plotly:
                        fig_abs_pl.add_trace(
                            go.Scatter(
                                x=v, y=e, mode="lines+markers",
                                name=label,
                                line=dict(color=f"rgba({int(color[0]*255)},{int(color[1]*255)},{int(color[2]*255)},0.95)", width=2),
                                marker=dict(size=6),
                                hovertemplate="V=%{x:.4f} A^3/atom<br>E=%{y:.6f} eV/atom<extra>%{fullData.name}</extra>",
                            )
                        )

                    eos_fit_obj = cur.get("_eos_fit_obj")
                    if eos_fit_obj is not None:
                        vfit = np.linspace(v.min() * 0.9, v.max() * 1.1, 200)
                        efit = eos_fit_obj.func(vfit)
                        ax_abs.plot(vfit, efit, color=color, linewidth=2, linestyle='-', alpha=0.85, zorder=2)
                        ax_abs.axvline(x=float(eos_fit_obj.v0), color=color, linestyle='--', alpha=0.6)
                        ax_abs.plot(float(eos_fit_obj.v0), float(eos_fit_obj.e0), 'o', color=color, markersize=7, markeredgecolor='black', markeredgewidth=0.8, zorder=4)
                        if use_plotly:
                            fig_abs_pl.add_trace(
                                go.Scatter(
                                    x=vfit, y=efit, mode="lines", showlegend=False,
                                    line=dict(color=f"rgba({int(color[0]*255)},{int(color[1]*255)},{int(color[2]*255)},0.7)", width=1.5),
                                    hoverinfo="skip",
                                )
                            )
                            # v0 marker as a separate point
                            fig_abs_pl.add_trace(
                                go.Scatter(
                                    x=[float(eos_fit_obj.v0)], y=[float(eos_fit_obj.e0)], mode="markers", showlegend=False,
                                    marker=dict(size=8, color=f"rgba({int(color[0]*255)},{int(color[1]*255)},{int(color[2]*255)},1.0)", line=dict(width=1, color="black")),
                                    hovertemplate="v0=%{x:.4f}<br>E0=%{y:.6f}<extra></extra>",
                                )
                            )

                    # Relative
                    e0 = float(eos_fit_obj.e0) if eos_fit_obj is not None else float(np.min(e))
                    ax_rel.scatter(v, e - e0, color=color, s=45, alpha=0.8, zorder=3, label=label)
                    if use_plotly:
                        fig_rel_pl.add_trace(
                            go.Scatter(
                                x=v, y=e - e0, mode="lines+markers",
                                name=label,
                                line=dict(color=f"rgba({int(color[0]*255)},{int(color[1]*255)},{int(color[2]*255)},0.95)", width=2),
                                marker=dict(size=6),
                                hovertemplate="V=%{x:.4f} A^3/atom<br>E−E0=%{y:.6f} eV/atom<extra>%{fullData.name}</extra>",
                            )
                        )
                    if eos_fit_obj is not None:
                        vfit = np.linspace(v.min() * 0.9, v.max() * 1.1, 200)
                        efit = eos_fit_obj.func(vfit) - e0
                        ax_rel.plot(vfit, efit, color=color, linewidth=2, linestyle='-', alpha=0.85, zorder=2)
                        ax_rel.axvline(x=float(eos_fit_obj.v0), color=color, linestyle='--', alpha=0.6)
                        ax_rel.plot(float(eos_fit_obj.v0), 0.0, 'o', color=color, markersize=7, markeredgecolor='black', markeredgewidth=0.8, zorder=4)
                        if use_plotly:
                            fig_rel_pl.add_trace(
                                go.Scatter(
                                    x=vfit, y=efit, mode="lines", showlegend=False,
                                    line=dict(color=f"rgba({int(color[0]*255)},{int(color[1]*255)},{int(color[2]*255)},0.7)", width=1.5),
                                    hoverinfo="skip",
                                )
                            )
                            fig_rel_pl.add_trace(
                                go.Scatter(
                                    x=[float(eos_fit_obj.v0)], y=[0.0], mode="markers", showlegend=False,
                                    marker=dict(size=8, color=f"rgba({int(color[0]*255)},{int(color[1]*255)},{int(color[2]*255)},1.0)", line=dict(width=1, color="black")),
                                    hovertemplate="v0=%{x:.4f}<br>E−E0=0<extra></extra>",
                                )
                            )

                # Decorate and save per-structure
                ax_abs.set_xlabel("Volume (A^3/atom)", fontsize=14)
                ax_abs.set_ylabel("Energy (eV/atom)", fontsize=14)
                ax_abs.set_title(f"EOS Curves — {struct}", fontsize=16)
                ax_abs.legend(fontsize=10, loc="center left", bbox_to_anchor=(1.02, 0.5), frameon=False, borderaxespad=0.0)
                ax_abs.grid(True, alpha=0.3)

                ax_rel.set_xlabel("Volume (A^3/atom)", fontsize=14)
                ax_rel.set_ylabel("Energy - E0 (eV/atom)", fontsize=14)
                ax_rel.set_title(f"EOS Curves Relative — {struct}", fontsize=16)
                ax_rel.legend(fontsize=10, loc="center left", bbox_to_anchor=(1.02, 0.5), frameon=False, borderaxespad=0.0)
                ax_rel.grid(True, alpha=0.3)
                ax_rel.axhline(y=0, color='black', linestyle='-', alpha=0.3)

                out_dir = self.abs_png.parent
                out_dir.mkdir(parents=True, exist_ok=True)
                abs_path = out_dir / f"{self.abs_png.stem}_{struct}.png"
                rel_path = out_dir / f"{self.rel_png.stem}_{struct}.png"
                fig_abs.savefig(abs_path, dpi=300, bbox_inches="tight", pad_inches=0.1)
                fig_rel.savefig(rel_path, dpi=300, bbox_inches="tight", pad_inches=0.1)
                plt.close(fig_abs); plt.close(fig_rel)

                abs_map[struct] = str(abs_path)
                rel_map[struct] = str(rel_path)

                # Write Plotly HTML (inline JS) when available
                if use_plotly:
                    fig_abs_pl.update_layout(
                        title=f"EOS Curves — {struct}",
                        xaxis_title="Volume (A^3/atom)", yaxis_title="Energy (eV/atom)",
                        template="plotly_white",
                        legend=dict(orientation="v"),
                    )
                    fig_rel_pl.update_layout(
                        title=f"EOS Curves Relative — {struct}",
                        xaxis_title="Volume (A^3/atom)", yaxis_title="Energy − E0 (eV/atom)",
                        template="plotly_white",
                        legend=dict(orientation="v"),
                    )
                    abs_html = out_dir / f"{self.abs_png.stem}_{struct}.html"
                    rel_html = out_dir / f"{self.rel_png.stem}_{struct}.html"
                    try:
                        write_html(fig_abs_pl, file=str(abs_html), full_html=True, include_plotlyjs="inline", auto_open=False)
                        write_html(fig_rel_pl, file=str(rel_html), full_html=True, include_plotlyjs="inline", auto_open=False)
                        abs_html_map[struct] = str(abs_html)
                        rel_html_map[struct] = str(rel_html)
                    except Exception:
                        pass

            out_obj.setdefault("plots", {})["abs_pngs"] = abs_map
            out_obj.setdefault("plots", {})["rel_pngs"] = rel_map
            if abs_html_map:
                out_obj.setdefault("plots", {})["abs_htmls"] = abs_html_map
            if rel_html_map:
                out_obj.setdefault("plots", {})["rel_htmls"] = rel_html_map

        # Strip private helpers and store curves
        for cur in curves_out:
            cur.pop("_eos_fit_obj", None)
            out_obj["curves"].append(cur)

        # Persist json (atomic write)
        self.out_json.parent.mkdir(parents=True, exist_ok=True)
        tmp = self.out_json.with_suffix(".tmp")
        tmp.write_text(json.dumps(out_obj, indent=2))
        tmp.replace(self.out_json)

        # Persist tsv (richer columns; per-atom units)
        with open(self.out_tsv, "w") as fh:
            fh.write("volume_scale\tvolume_A3_per_atom\tenergy_eV_per_atom\tstatus\tstructure\tcombination\tworkdir\n")
            for p in all_points:
                e = "" if p["energy_eV"] is None else f"{p['energy_eV']:.9f}"
                v = "" if p.get("volume_A3") is None else f"{p['volume_A3']:.6f}"
                fh.write(
                    f"{p['volume_scale']:.6f}\t{v}\t{e}\t{p['status']}\t{p['structure']}\t{p['combination']}\t{p['workdir']}\n"
                )

        # Also update eos.json with parsed energies
        Path(self.eos_json).write_text(model.model_dump_json(indent=2))

        return out_obj
