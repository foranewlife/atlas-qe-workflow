"""
EOS Post-Processing: parse energies/volumes per curve, fit EOS, and plot.

Inputs:
- eos.json (generated by aqflow eos), which contains tasks, structures_info, combinations_info, curves_index

Outputs (under aqflow_data/ by default):
- eos_post.json: multi-curve structured data (per-curve points + fits)
- eos_points.tsv: tabular data with columns: volume_scale, volume_A3, energy_eV, status, structure, combination, workdir
- eos_curve.png / eos_curve_relative.png: absolute and relative EOS curves (multi-curve overlay)
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import json
import time
import logging

from .models import EosModel
from aqflow.software.parsers import parse_volume as sw_parse_volume
import numpy as np
import matplotlib.pyplot as plt

logger = logging.getLogger(__name__)
from pymatgen.analysis.eos import EOS

# Assume dependencies exist per project convention; no auto-install here.


def _read_text(path: Path) -> str:
    try:
        return Path(path).read_text(errors="ignore")
    except Exception:
        return ""


def _detect_software_from_combo(combination: str) -> Optional[str]:
    c = (combination or "").lower()
    if "qe" in c:
        return "qe"
    if "atlas" in c:
        return "atlas"
    return None


def _parse_energy_any(software: str, text: str) -> Optional[float]:
    # Deprecated: energies come from eos.json; keep stub for compatibility
    return None


def _parse_volume_any(software: str, workdir: Path) -> Optional[float]:
    return sw_parse_volume(software, workdir)


def _polyfit_quadratic(xs: List[float], ys: List[float]) -> Optional[Tuple[float, float, float]]:
    """Fit y = a x^2 + b x + c via least squares (stable for small N)."""
    if len(xs) < 3:
        return None
    X = np.vstack([np.array(xs) ** 2, np.array(xs), np.ones(len(xs))]).T
    try:
        a, b, c = np.linalg.lstsq(X, np.array(ys), rcond=None)[0]
        return float(a), float(b), float(c)
    except Exception:
        return None


def _fit_pymatgen(vols: List[float], ys: List[float], model: str) -> Tuple[Optional[Dict], Optional[object]]:
    if len(vols) >= 3 and len(vols) == len(ys):
        try:
            eos = EOS(eos_name=model)
            fit = eos.fit(vols, ys)
            return (
                {
                    "e0": float(fit.e0),
                    "v0": float(fit.v0),
                    "b0_GPa": float(fit.b0_GPa),
                    "b1": float(fit.b1),
                    "n_points": len(vols),
                },
                fit,
            )
        except Exception as ex:
            return ({"error": f"pymatgen fit failed: {ex}"}, None)
    return (None, None)


def _base_dir_from_model(model: EosModel, eos_json_path: Path) -> Path:
    try:
        return Path(model.meta.config_path).parent
    except Exception:
        return eos_json_path.parent


def _combination_software(model: EosModel, combo_name: str) -> Optional[str]:
    info = (model.combinations_info or {}).get(combo_name) if hasattr(model, "combinations_info") else None
    if info and isinstance(info, dict):
        sw = info.get("software")
        if isinstance(sw, str) and sw:
            return sw
    return _detect_software_from_combo(combo_name)


    # removed: no special per-atom handling; energy parsing unified via software parsers


@dataclass
class EosPostProcessor:
    eos_json: Path = Path.cwd() / "aqflow_data" / "eos.json"
    out_json: Path = Path.cwd() / "aqflow_data" / "eos_post.json"
    out_tsv: Path = Path.cwd() / "aqflow_data" / "eos_points.tsv"
    fit: str = "quad"  # "none" | "quad"
    eos_model_name: str = "birch_murnaghan"  # pymatgen EOS model name
    make_plots: bool = True
    abs_png: Path = Path.cwd() / "aqflow_data" / "eos_curve.png"
    rel_png: Path = Path.cwd() / "aqflow_data" / "eos_curve_relative.png"

    def run(self) -> Dict:
        raw = json.loads(Path(self.eos_json).read_text())
        model = EosModel.model_validate(raw)

        # Accumulate all points (flat) and group into curves by (structure|combination)
        all_points: List[Dict] = []
        curves: Dict[str, Dict] = {}
        # Resolve relative paths against config directory
        try:
            base_dir = Path(model.meta.config_path).parent
        except Exception:
            base_dir = Path(self.eos_json).parent
        for t in model.tasks:
            # Resolve workdir
            workdir_path = Path(t.workdir)
            if not workdir_path.is_absolute():
                workdir_path = base_dir / workdir_path
            # Determine software for volume parsing; energy comes from eos.json
            software = _combination_software(model, t.combination) or "qe"
            e = t.energy
            # Determine volume via software parser
            vol = _parse_volume_any(software, workdir_path)
            # Persist volume back to model so eos.json contains volume info
            try:
                t.volume = vol  # type: ignore[attr-defined]
            except Exception:
                pass

            point = {
                "structure": t.structure,
                "combination": t.combination,
                "volume_scale": t.volume_scale,
                "energy_eV": e,
                "status": t.status,
                "workdir": t.workdir,
                "volume_A3": vol,
            }
            all_points.append(point)
            logger.info(
                f"Parsed task {workdir_path}: energy={e}, volume={vol}, status={t.status}"
            )

            # Group key: one curve per (structure, combination)
            key = f"{t.structure}|{t.combination}"
            cur = curves.setdefault(key, {
                "key": key,
                "structure": t.structure,
                "combination": t.combination,
                "software": software,
                "points": [],
            })
            cur["points"].append(point)
            

        # Per-curve fits
        curves_out: List[Dict] = []
        for key, cur in curves.items():
            pts_ok = [p for p in cur["points"] if p["energy_eV"] is not None]
            xs: List[float] = [float(p["volume_scale"]) for p in pts_ok]
            ys: List[float] = [float(p["energy_eV"]) for p in pts_ok]
            vols: List[float] = [float(p["volume_A3"]) for p in pts_ok if p["volume_A3"] is not None]

            fit_result: Dict[str, Optional[float] | str | int] = {"method": self.fit}
            if self.fit == "quad" and len(xs) >= 3:
                sol = _polyfit_quadratic(xs, ys)
                if sol:
                    a, b, c = sol
                    vmin = None
                    emin = None
                    if abs(a) > 1e-12:
                        vmin = -b / (2 * a)
                        emin = a * vmin * vmin + b * vmin + c
                    fit_result.update(
                        {
                            "a": a,
                            "b": b,
                            "c": c,
                            "vmin": vmin,
                            "emin": emin,
                            "n_points": len(xs),
                        }
                    )

            # pymatgen EOS fit per-curve
            pmg_fit, eos_fit_obj = _fit_pymatgen(vols, ys, self.eos_model_name)

            curves_out.append(
                {
                    "key": key,
                    "structure": cur["structure"],
                    "combination": cur["combination"],
                    "software": cur["software"],
                    "points": cur["points"],
                    "fit": fit_result,
                    "pmg_fit": pmg_fit,
                    "_eos_fit_obj": eos_fit_obj,  # internal use for plotting; popped later
                }
            )

        out_obj: Dict = {
            "meta": {
                "created_at": time.time(),
                "source": str(self.eos_json),
                "fit": self.fit,
                "pymatgen_eos": self.eos_model_name,
            },
            # flat points retained for quick grep; multi-curve lives in curves
            "points": all_points,
            "curves": [],  # will fill without private keys
        }

        # Plotting (absolute and relative) with multiple curves
        if self.make_plots and curves_out:
            # Absolute energy plot
            fig_abs, ax_abs = plt.subplots()
            # Relative energy plot
            fig_rel, ax_rel = plt.subplots()

            # Choose colors
            n = max(1, len(curves_out))
            cmap = plt.cm.get_cmap("tab10", min(10, n)) if n <= 10 else plt.cm.get_cmap("tab20", min(20, n))

            for idx, cur in enumerate(curves_out):
                color = cmap(idx % cmap.N)
                # Extract numeric vectors (sorted by volume for smooth lines)
                vols = np.array([p["volume_A3"] for p in cur["points"] if p["energy_eV"] is not None and p["volume_A3"] is not None], dtype=float)
                ens = np.array([p["energy_eV"] for p in cur["points"] if p["energy_eV"] is not None and p["volume_A3"] is not None], dtype=float)
                if len(vols) == 0:
                    continue
                order = np.argsort(vols)
                v = vols[order]
                e = ens[order]

                # Legend: structure | combination [B0=.. GPa if available]
                pmg = cur.get("pmg_fit") or {}
                if isinstance(pmg, dict) and pmg.get("b0_GPa") is not None and not pmg.get("error"):
                    label = f"{cur['structure']} | {cur['combination']} | B0={pmg['b0_GPa']:.2f} GPa"
                else:
                    label = f"{cur['structure']} | {cur['combination']}"
                ax_abs.scatter(v, e, color=color, s=45, alpha=0.8, zorder=3, label=label)

                eos_fit_obj = cur.get("_eos_fit_obj")
                if eos_fit_obj is not None:
                    vfit = np.linspace(v.min() * 0.9, v.max() * 1.1, 200)
                    efit = eos_fit_obj.func(vfit)
                    ax_abs.plot(
                        vfit,
                        efit,
                        color=color,
                        linewidth=2,
                        linestyle='-',
                        alpha=0.85,
                        zorder=2,
                    )
                    ax_abs.axvline(x=float(eos_fit_obj.v0), color=color, linestyle='--', alpha=0.6)
                    ax_abs.plot(
                        float(eos_fit_obj.v0),
                        float(eos_fit_obj.e0),
                        'o',
                        color=color,
                        markersize=7,
                        markeredgecolor='black',
                        markeredgewidth=0.8,
                        zorder=4,
                    )

                # Relative
                e0 = float(eos_fit_obj.e0) if eos_fit_obj is not None else float(np.min(e))
                ax_rel.scatter(v, e - e0, color=color, s=45, alpha=0.8, zorder=3, label=label)
                if eos_fit_obj is not None:
                    vfit = np.linspace(v.min() * 0.9, v.max() * 1.1, 200)
                    efit = eos_fit_obj.func(vfit) - e0
                    ax_rel.plot(
                        vfit,
                        efit,
                        color=color,
                        linewidth=2,
                        linestyle='-',
                        alpha=0.85,
                        zorder=2,
                    )
                    ax_rel.axvline(x=float(eos_fit_obj.v0), color=color, linestyle='--', alpha=0.6)
                    ax_rel.plot(
                        float(eos_fit_obj.v0),
                        0.0,
                        'o',
                        color=color,
                        markersize=7,
                        markeredgecolor='black',
                        markeredgewidth=0.8,
                        zorder=4,
                    )

            # Decorate and save
            for ax in (ax_abs,):
                ax.set_xlabel("Volume (Ang^3)", fontsize=14)
                ax.set_ylabel("Energy (eV)", fontsize=14)
                ax.set_title("Equation of State (EOS) Curves", fontsize=16)
                ax.legend(fontsize=10)
                ax.grid(True, alpha=0.3)
            fig_abs.tight_layout()
            self.abs_png.parent.mkdir(parents=True, exist_ok=True)
            fig_abs.savefig(self.abs_png, dpi=300)
            plt.close(fig_abs)

            for ax in (ax_rel,):
                ax.set_xlabel("Volume (Ang^3)", fontsize=14)
                ax.set_ylabel("Energy - E0 (eV)", fontsize=14)
                ax.set_title("EOS Curves Relative to Equilibrium Energy", fontsize=16)
                ax.legend(fontsize=10)
                ax.grid(True, alpha=0.3)
                ax.axhline(y=0, color='black', linestyle='-', alpha=0.3)
            fig_rel.tight_layout()
            self.rel_png.parent.mkdir(parents=True, exist_ok=True)
            fig_rel.savefig(self.rel_png, dpi=300)
            plt.close(fig_rel)

            out_obj.setdefault("plots", {})["abs_png"] = str(self.abs_png)
            out_obj.setdefault("plots", {})["rel_png"] = str(self.rel_png)

        # Strip private helpers and store curves
        for cur in curves_out:
            cur.pop("_eos_fit_obj", None)
            out_obj["curves"].append(cur)

        # Persist json (atomic write)
        self.out_json.parent.mkdir(parents=True, exist_ok=True)
        tmp = self.out_json.with_suffix(".tmp")
        tmp.write_text(json.dumps(out_obj, indent=2))
        tmp.replace(self.out_json)

        # Persist tsv (richer columns)
        with open(self.out_tsv, "w") as fh:
            fh.write("volume_scale\tvolume_A3\tenergy_eV\tstatus\tstructure\tcombination\tworkdir\n")
            for p in all_points:
                e = "" if p["energy_eV"] is None else f"{p['energy_eV']:.9f}"
                v = "" if p.get("volume_A3") is None else f"{p['volume_A3']:.6f}"
                fh.write(
                    f"{p['volume_scale']:.6f}\t{v}\t{e}\t{p['status']}\t{p['structure']}\t{p['combination']}\t{p['workdir']}\n"
                )

        # Also update eos.json with parsed energies
        Path(self.eos_json).write_text(model.model_dump_json(indent=2))

        return out_obj
